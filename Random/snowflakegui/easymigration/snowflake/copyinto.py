# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/06_snowflake_copyinto.ipynb (unless otherwise specified).

__all__ = ['CopyInto']

# Cell
from ..imports import *
from .query import *
from ..utils.parseyaml import *
from ..azure.filehandling import *
from easymigration import files

# Cell
class CopyInto(SnowflakeTool):

    def __init__(self,
                 sfAccount: str = None,
                 sfUser: str = None,
                 sfPswd: str = None,
                 sfWarehouse: str = None,
                 sfDatabase: str = None,
                 sfSchema: str = None,
                 sfRole: str = None,
                 ):
        """
        Instatiation of snowflake mover class inheriting the SnowflakeTool
        class from utils.
        Args:
            sfUser (str, optional): snowflake credential passed as string
            sfPswd (str, optional): snowflake credential passed as string
            sfWarehouse (str, optional): snowflake credential passed as string
            sfDatabase (str, optional): snowflake credential passed as string
            sfSchema (str, optional): snowflake credential passed as string
            sfRole (str, optional): snowflake credential passed as string
            logger ([type], optional): pass custom logger as many libraries are set to Warning. Defaults to None.
        """
        super().__init__(sfAccount,
                         sfUser,
                         sfPswd,
                         sfWarehouse,
                         sfDatabase,
                         sfSchema,
                         sfRole)
        self._logger = logger if logger is not None else logging.getLogger(__name__)

    def insert_csv(self,
                   blob_name: str = None,
                   blob_path: str = None,
                   storage_account: str = None,
                   container_name: str = None,
                   table_name: str = None,
                   sas_token: str = None,
                   fail_on_no_insert: bool = False,
                   delimiter: str = ',',
                   ):
        """
        Copies a csv file into a given snowflake table from
        blob

        :param blob_name: name of file in blob
        :param blob_path: path to file in blob
        :param storage_account: blob storage account name
        :param container_name: Azure container ID
        :param sas_token: shared access signature token for azure blob
        :param table_name: file to get the import data statement
        :param delimiter: csv delimeter type

        :return response: snowflake response from the copy into statement
        """

        # make blob name here if a path is given
        if blob_path:
            blob_name = blob_path + '/' + blob_name

        # read the sql file from the libary
        sql_file = os.path.join(os.path.abspath(files.__path__[0]), 'import_data_csv.sql')
        with open(sql_file) as file:
            query = ' '.join(file.readlines())
        inserts = ['INSERT_AZURE_STORAGE_ACCOUNT_NAME_HERE',
                   'INSERT_TABLE_NAME_HERE',
                   'INSERT_CONTAINER_NAME_HERE',
                   'INSERT_FILE_NAME_HERE',
                   'INSERT_AZURE_SAS_TOKEN_HERE',
                   'INSERT_DELIMITER_HERE']
        insert = [storage_account, table_name, container_name, blob_name, sas_token, delimiter]
        for k, v in zip(inserts, insert):
            query = query.replace(k, v)
        self._logger.info(query)

        # execute the snowflake command
        response = self.run_str_query(query)

        # output query results
        self._logger.info('snowflake insertion output:')
        self._logger.info(response)

        if response is None:
            self._logger.info('No files uploaded to snowflake')
            if fail_on_no_insert:
                raise('fail_on_no_insert was equal TRUE, so program raised error')
        else:
            # check if the load was executed correctly
            assert (response['rows_parsed'][0] == response['rows_loaded'][0]), \
                "Rows loaded and parsed are not equal"

        return response
