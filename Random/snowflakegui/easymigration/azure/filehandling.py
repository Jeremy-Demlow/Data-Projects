# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_azure.ipynb (unless otherwise specified).

__all__ = ['FileHandling', 'unlink_files']

# Cell
from ..imports import *

# Cell
class FileHandling:
    def __init__(self, connection_string, logger=logger):
        self.blob_service_client = BlobServiceClient.from_connection_string(connection_string)
    """
    file handling for all easymigration Azure blob storage. Both upload and download
    have there own clients with in this class so that they can call different
    containers with in the storage account within on init. This is designed,
    but can be removed if we still this to be a waste.
    Args:
        connection_string (str): azure connection string to blob storage
        logger: logging choices can be overwritten if you want the defaults
    """

    def upload(self,
               container_name: str,
               file_path: str,
               dest: str = '',
               overwrite: bool = False):
        """
        uploads file(s) to azure blob storage
        Args:
            container_name (str): azure blob container name
            file_path (str): file or directory to upload to azure
            dest (str, optional): destination in azure/ file name in azure. Defaults to ''.
            overwrite (bool, optional): write over same file names. Defaults to False.
        """
        self.container_name = container_name
        self.container_client = self.blob_service_client.get_container_client(container_name)
        self.create_blob_container(container_name=container_name)
        if (os.path.isdir(file_path)):
            self.load_dir = True
            self.upload_dir(file_path, overwrite)
        else:
            self.load_dir = False
            self.upload_file(file_path, dest, overwrite)

    def upload_file(self,
                    file_path: str,
                    blob_name: str,
                    overwrite=False):
        """
        simply uploads a file to blob storage
        Args:
            file_path (str): file to blob
            blob_name (str): destination in blob
            overwrite (bool, optional): write over same file names. Defaults to False.
        """
        logger.info(f'Uploading {file_path}, to to Azure Storage {blob_name}')
        with open(file_path, "rb") as file:
            try:
                blob_name = file_path if self.load_dir is True else blob_name
                self.container_client.upload_blob(data=file, name=blob_name, overwrite=overwrite)
            except Exception as e:
                logger.error(f'"Error Message: {e.error_code.value}"')
        logger.info('Azure Upload Complete')

    def upload_dir(self,
                   directory: str,
                   overwrite: bool = False):
        """
        simply uploads a directory to azure blob note with python
        we can have arguement be used from upload will figure
        that out hopefully
        Args:
            directory (str): directory that is being moved to blob
            overwrite (bool, optional): write over same file names. Defaults to False.
        """
        prefix = os.path.basename(directory) + '/'
        # Walk Through Directory
        for root, dirs, files in os.walk(directory):
            for name in files:
                # root, director == . when at root level of moved directory
                dir_part = os.path.relpath(root, directory)
                dir_part = '' if dir_part == '.' else dir_part + '/'
                file_path = os.path.join(root, name)
                blob_path = prefix + dir_part + name
                self.upload_file(file_path, blob_path)

    def create_blob_container(self,
                              container_name: str = str(uuid.uuid4()),
                              unique: bool = False):
        """
        creates/check for container when ``upload`` is called, but
        this function can be used seperately to create
        a new container in isolation within the specific storage account
        Args:
            container_name (str, optional): creates azure blob container name. Defaults to str(uuid.uuid4()).
            unique (bool, optional): add a unique tail to container name. Defaults to False.
        """
        regex = re.compile(r'[@_!#$%^&*()<>?/\|}{~:]')
        # Check if container_name is valid
        if (regex.search(container_name) is None):
            logger.info(f'{container_name} is a valid')
        else:
            container_name = re.sub(r'[\W_]+', '', container_name)
            logger.info(f'container_name changed to {container_name}')
        if unique:
            container_name = container_name + str(uuid.uuid4())
        else:
            container_name = container_name
        # Current Python SDK doesn't support exist
        try:
            # Create the container
            _ = self.blob_service_client.create_container(container_name)
        except Exception as e:
            logger.info(f'{e.error_code.value}')

    def download(self,
                 blob_location: str,
                 dest: str,
                 container_name: str,
                 blob_path: str = '',
                 directory: str = None,
                 recursive: bool = True,
                 overwrite: bool = False):
        """
        Args:
            blob_location (str): location in container
            dest (str): local destination of file
            container_name (str): azure blob container name.
            blob_path (str, optional): path in blob helps search. Defaults to ''.
            directory (str, optional): not useful. Defaults to None.
            recursive (bool, optional): helps with search for file can be false if blob_path is known. Defaults to True.
            overwrite (bool, optional): write over same file names. Defaults to False.
        """
        if not dest.endswith('/'):
            dest += '/'
        if blob_location.endswith('/'):
            if blob_path == '':
                blobs = self.ls_blob(container_name=container_name, path=blob_path, recursive=recursive)
                blobs = [blobs for blobs in blobs if os.path.basename(os.path.normpath(blob_location)) in blobs]
            else:
                blobs = self.ls_blob(container_name=container_name, path=blob_path, recursive=recursive)
                blobs = [blob_location + blob for blob in blobs]
            if directory and not directory.endswith('/'):
                directory += '/'
            for blob in blobs:
                logger.info(f'Downloading {blob}')
                if directory:
                    self.download_file(container_name, blob, os.path.join(dest, directory), overwrite)
                else:
                    self.download_file(container_name, blob, dest, overwrite)
        else:
            self.download_file(container_name, os.path.basename(os.path.normpath(blob_location)), dest, overwrite)
        logger.info('Download complete')

    def download_file(self,
                      container_name: str,
                      file: str,
                      file_path: str,
                      overwrite: bool = False):
        """
        Args:
            container_name (str): azure blob container name.
            file (str): file to download from blob
            file_path (str): location to put `file`
            overwrite (bool, optional): write over same file names. Defaults to False.
        """
        if file_path.endswith('.'):
            file_path += '/'
        blob_dest = file_path + os.path.basename(file) if file_path.endswith('/') else file_path
        logger.info(f'{file} to {blob_dest}')
        if not overwrite:
            if os.path.exists(blob_dest):
                logger.warning('file path already exist change overwrite to ``True`` if you want to overwrite file')
                return
        os.makedirs(os.path.dirname(blob_dest), exist_ok=True)
        download_client = self.blob_service_client.get_container_client(container_name)
        downloader = download_client.get_blob_client(blob=file)
        with open(blob_dest, 'wb') as file:
            data = downloader.download_blob()
            file.write(data.readall())

    def ls_blob(self,
                container_name: str,
                path: str,
                recursive: bool = False):
        """
        Args:
            container_name (str): azure blob container name.
            path (str): blob path to look at
            recursive (bool, optional): recurisve look. Defaults to False.

        Returns:
            list: file list
        """
        if not path == '' and not path.endswith('/'):
            path += '/'
        download_client = self.blob_service_client.get_container_client(container_name)
        blob_looker = download_client.list_blobs(name_starts_with=path)
        files = []
        for blob in blob_looker:
            relative_path = os.path.relpath(blob.name, path)
            if recursive or not '/' in relative_path: # NOQA:
                files.append(relative_path)
        return files

    def rm_files(self,
                 container_name: str,
                 delete_path: str = '',
                 recursive: bool = False):
        """
        removes files from storage account
        Args:
            container_name (str): azure blob container name.
            delete_path (str, optional): what to delete file or directory. Defaults to ''.
            recursive (bool, optional): recursive delete. Defaults to False.
        """
        if not delete_path == '' and not delete_path.endswith('/'):
            delete_path, delete_file = delete_path.rsplit('/', 1)
            delete_path += '/'
            blobs = self.ls_blob(container_name, delete_path, recursive)
            if delete_file in blobs:
                blobs = [delete_file]
        else:
            blobs = self.ls_blob(container_name, delete_path, recursive)
        if not blobs:
            logger.warning('location in blob is empty')
            return
        blobs = [delete_path + blob for blob in blobs]
        logger.info(f'files to be removed {blobs}')
        delete_client = self.blob_service_client.get_container_client(container_name)
        if len(blobs) > 1:
            delete_client.delete_blobs(*blobs)
        else:
            delete_client.delete_blob(*blobs)

    def rm_container(self,
                     container_name: str):
        "remove container from storage account"
        self.blob_service_client.delete_container(container_name)

    def ls_containers(self,
                      name_starts_with: str = None):
        "show containers in storage account"
        container_names = self.blob_service_client.list_containers(name_starts_with=name_starts_with)
        for names in container_names:
            print(names['name'])

# Cell
def unlink_files(files: list, file_path: str = './'):
    """
    clean up tool for files that shouldn't be there

    Args:
        files (list): can be a list of just one file to remove
        file_path (str, optional): location of the file. Defaults to './'.
    """
    file_list = files
    for x in file_list:
        os.unlink(os.path.join(file_path, x))